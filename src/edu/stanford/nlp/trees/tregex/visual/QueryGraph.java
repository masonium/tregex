package edu.stanford.nlp.trees.tregex.visual;

import 
java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

//import sun.misc.Queue;

public class QueryGraph {
	
	List<QueryNode> nodes;
	List<QueryEdge> edges;
	
	Map<QueryNode, String> assignedLabels;
	
	public QueryGraph() {
	  this.nodes = new ArrayList<QueryNode>();
	  this.edges = new ArrayList<QueryEdge>();		
	  assignedLabels = new HashMap<QueryNode, String>();
	}
	
	/**
	 * convert to a tregex query
	 * breadth-first search, starting with the head node
	 */
	public String toTregexQuery( QueryNode headNode ) {				
		String baseQuery = visitNode( headNode, null, new HashSet<QueryNode>(), new HashSet<QueryEdge>());
		
		StringBuilder sb = new StringBuilder( baseQuery );
		
		// remove unnecessary labels
		// (auto-generated labels that appear only once
		for ( String l: assignedLabels.values() ) {
		  String q = "=" + l;
		  int firstAppearance = sb.indexOf( q );
		  if (firstAppearance < 0)
		    continue;
		  
		  int secondAppearance = sb.indexOf( q, firstAppearance + q.length() );
		  if (secondAppearance < 0)
		    sb.delete( firstAppearance, firstAppearance+q.length() );
		}
		
		return sb.toString();//toString();//baseQuery;//sb.toString();
	}
	
	public String visitNode( QueryNode currentNode, QueryNode previousNode,
			Set<QueryNode> visitedNodes, Set<QueryEdge> visitedEdges) {
		
	  String label = currentNode.label.trim();
	  if (label.isEmpty())
	    label = assignedLabels.get( currentNode );
	    
	  // if we've seen the node before, we just reference it without delving further
		if ( visitedNodes.contains( currentNode ) )
			return "=" + label;
		
		boolean autoGenerated = isAutoGenerated(label);
		
		// mark that we've seen the node
		visitedNodes.add( currentNode );
		String query = currentNode.pattern;
		
		// Vertices of degree 0-1 cannot be visited more than once, so don't 
		// need to bother actually labeling them.
		if (currentNode.getDegree() > 1 || !autoGenerated)
		  query = query + "=" + label;
				
		for ( QueryEdge e: currentNode.outgoingEdges ) {
			// skip any relations already rendered
			if ( visitedEdges.contains(e) )
				continue;
			
			visitedEdges.add(e);
			
			// render the edge
			query += " " + e.render( false ) + " (" + visitNode( e.n2, currentNode, 
					visitedNodes, visitedEdges ) + ")";
			
		}
		for ( QueryEdge e: currentNode.incomingEdges ) {
			// skip any relations already rendered
			if ( visitedEdges.contains(e) )
				continue;
			
			visitedEdges.add(e);
			
			// render the edge
			query += " " + e.render( true ) + " (" + visitNode( e.n1, currentNode, 
					visitedNodes, visitedEdges ) + ")";
			
		}
		
		return query;
	}
	
	private void assignLabel( QueryNode node ) {
	  assignedLabels.put( node, generateLabel() );
	}
	
	private int labelCounter = 0;
	private String generateLabel() {
		return "__g" + (labelCounter++);
	}
  private boolean isAutoGenerated(String label) {
    return label.startsWith( "__" );
  }
  
	public QueryNode createNode(  ) {
		QueryNode newNode = new QueryNode();
				
		nodes.add( newNode );
		assignLabel( newNode );
		return newNode;
	}
	
	public void removeNode( QueryNode node ) {	  
	  nodes.remove( node );
	  for (QueryEdge e: node.incomingEdges)
	    e.n1.outgoingEdges.remove( e );
	  for (QueryEdge e: node.outgoingEdges)
	    e.n2.incomingEdges.remove( e );
	}
	
	/*
	 * Returns a newly created edge from n1 to n2
	 * does nothing if there already exists an edge between n1 and n2, 
	 * or such an edge cannot otherwise be created.
	 */
	public QueryEdge createEdge(QueryNode n1, QueryNode n2) {
	  if ( n1 == n2 || n1.hasEdgeTo( n2 ) || n1.hasEdgeFrom( n2 ) )
	    return null;
	  if ( !nodes.contains( n1 ) || !nodes.contains( n2 ))
	    return null;
	  
	  QueryEdge e = new QueryEdge();
	  addEdge( e, n1, n2 );
	  return e;
	}
	
	private void addEdge(QueryEdge e, QueryNode n1, QueryNode n2) {
		e.n1 = n1;
		e.n2 = n2;
		n1.outgoingEdges.add( e );
		n2.incomingEdges.add( e );
		edges.add( e );
	}
	
	public void removeEdge( QueryEdge e ) {
		e.n1.outgoingEdges.remove( e );
		e.n2.incomingEdges.remove( e );
		edges.remove( e );
	}
	
	public void setHeadNode( QueryNode node ) {
	  assert( node != null );
	  assert( nodes.contains( node ) );
	}
	
	public int getNumNodes() { 
	  return nodes.size();
	}
	
	public List<QueryNode> getNodes() {
	  List<QueryNode> nodes = new ArrayList<QueryNode>();
	  nodes.addAll( this.nodes );
	  return nodes;
	}
	
	@Override
	public String toString() {
	  StringBuilder sb = new StringBuilder();
	  for (QueryNode n: nodes) {
	    sb.append( assignedLabels.get( n ) );
	    for (QueryEdge e: n.outgoingEdges) {
	      sb.append(assignedLabels.get( e.n2 ));
	    }
	    sb.append(", ");
	  }
	  return sb.toString();
	}
	
	public static void main( String [] args ) {
	  QueryGraph graph = new QueryGraph();
	  QueryNode n1 = graph.createNode();
	  QueryNode n2 = graph.createNode();
	  QueryNode n3 = graph.createNode();
	  
	  QueryEdge e1 = new QueryEdge( EdgeDescriptor.Type.DESCENDANT);
	  graph.addEdge( e1, n1, n2 );
	  QueryEdge e2 = new QueryEdge( EdgeDescriptor.Type.SIBLING);
	  graph.addEdge( e2, n2, n3 );
	  
	  System.out.println( graph.toTregexQuery(n1) );
	}
}
